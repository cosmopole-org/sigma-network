/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};

;// CONCATENATED MODULE: ./src/runtime/react/react.js
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
let targetFunc;
let callbackDict = {};
let keyCounter = 1;
let vdom;
let rendering;
let stack = [];
let compCache = {};
let keyCache = {};
let renderStack = [];
let stateCounter = 0;
let indexCounter = 0;
let updatingTreePath;
__webpack_require__.g.trigger = function trigger(callbackId) {
  let cb = callbackDict[callbackId];
  if (cb) cb();
};
const isFunction = target => typeof target === 'function';
const isObject = target => typeof target === 'object' && target !== null;
class Element {
  constructor(tag, props, events, children) {
    _defineProperty(this, "tag", void 0);
    _defineProperty(this, "key", void 0);
    _defineProperty(this, "props", {});
    _defineProperty(this, "events", {});
    _defineProperty(this, "children", []);
    this.tag = tag;
    let path = renderStack.join("/");
    if (keyCache[path]) {
      this.key = keyCache[path];
    } else {
      let key = Math.random().toString().substring(2);
      keyCache[path] = key;
      this.key = key;
    }
    this.props = props !== null && props !== void 0 ? props : {};
    this.events = events !== null && events !== void 0 ? events : {};
    this.children = children !== null && children !== void 0 ? children : [];
  }
  addChild(child) {
    let j = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    if (Array.isArray(child)) {
      child.forEach((nestedChild, i) => {
        this.addChild(nestedChild, i + j);
      });
    } else if (this.children[j] == undefined) {
      this.children.push(child);
    } else if (JSON.stringify(child) !== JSON.stringify(this.children[j])) {
      this.children[j] = child;
    }
  }
  removeChild(index) {
    this.children.splice(index, 1);
  }
  static create(tag) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      children[_key - 2] = arguments[_key];
    }
    if (props === undefined || props === null) {
      props = {};
    }
    if (children === undefined || children === null) {
      children = [];
    }
    if (isFunction(tag)) {
      let previoudRendering = rendering;
      let renderStackBackup = [...renderStack];
      let copyOfRenderStack = [...renderStack, tag.name + "/" + indexCounter];
      let path = renderStack.join("/");
      let ic = indexCounter;
      rendering = () => {
        let prevStateCounter = stateCounter;
        stateCounter = 0;
        stack.push([]);
        renderStack = copyOfRenderStack;
        let prevIndexCounter = indexCounter;
        indexCounter = 0;
        let res = tag(props, children);
        indexCounter = prevIndexCounter;
        renderStack = renderStackBackup;
        let states = stack.pop();
        let key = (path.length > 0 ? path + "/" : "") + tag.name + "/" + ic;
        if (!compCache[key]) {
          compCache[key] = states;
        }
        stateCounter = prevStateCounter;
        if (vdom && key === updatingTreePath) {
          message(JSON.stringify({
            action: "update",
            element: res
          }));
        }
        return res;
      };
      let res = rendering();
      renderStack = renderStackBackup;
      rendering = previoudRendering;
      return res;
    }
    let element = new Element(tag);
    Object.entries(props).forEach(_ref => {
      let [name, value] = _ref;
      if (name.startsWith('on')) {
        let callbackId = (keyCounter++).toString();
        callbackDict[callbackId] = value;
        element.events[name.toLowerCase().substring(2)] = callbackId;
      } else {
        element.props[name] = value;
      }
    });
    let prevIndexCounter = indexCounter;
    indexCounter = 0;
    const res = children.map(child => {
      const value = isFunction(child) ? child() : child;
      return value;
    });
    indexCounter = prevIndexCounter;
    element.addChild(res);
    indexCounter++;
    return element;
  }
}
class Dep {
  constructor() {
    this.subs = new Set();
  }
  depend(rendering) {
    rendering && this.subs.add(rendering);
  }
  notify() {
    this.subs.forEach(sub => sub());
  }
}
const createEffect = fun => {
  targetFunc = fun;
  targetFunc();
  targetFunc = null;
};
const clone = (acc, target) => {
  if (isObject(acc)) {
    Object.keys(acc).forEach(key => {
      if (isObject(acc[key])) target[key] = clone(acc[key], target[key]);else target[key] = acc[key];
    });
  } else {
    target = acc;
  }
  return target;
};
const setter = (prx, dep, path) => data => {
  updatingTreePath = path;
  const result = isFunction(data) ? data(prx.data) : data;
  if (isObject(result)) clone(result, prx.data);else prx.data = result;
  indexCounter = 0;
  dep.notify();
};
const createOptions = dep => ({
  get(target, key) {
    if (isObject(target[key])) return new Proxy(target[key], createOptions(dep));
    return target[key];
  }
});
const React = {
  createElement: function (tag, props) {
    for (var _len2 = arguments.length, children = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
      children[_key2 - 2] = arguments[_key2];
    }
    return Element.create(tag, props, ...children);
  },
  init: rootComp => {
    vdom = rootComp;
    message(JSON.stringify({
      action: "init",
      element: rootComp
    }));
    return vdom;
  },
  useState: data => {
    let key = renderStack.join("/");
    let result;
    let states = compCache[key];
    if (states) {
      result = states[stateCounter];
      stateCounter++;
    } else {
      const dep = new Dep();
      dep.depend(rendering);
      const prx = new Proxy({
        data
      }, createOptions(dep));
      result = [() => prx.data, setter(prx, dep, key)];
      stack[stack.length - 1].push(result);
      stateCounter++;
    }
    return result;
  },
  setTimeout: (cb, time) => {
    let callbackId = (keyCounter++).toString();
    callbackDict[callbackId] = cb;
    message(JSON.stringify({
      action: "setTimeout",
      callbackId,
      time
    }));
  }
};
/* harmony default export */ const react = (React);
;// CONCATENATED MODULE: ./src/runtime/react/index.js


;// CONCATENATED MODULE: ./src/components/App.jsx

const Counter = () => {
  const [count, setCount] = react.useState(0);
  let onClick = () => {
    setCount(c => c + 1);
  };
  return /*#__PURE__*/react.createElement("button", {
    style: "width: 200px; height: 200px;",
    onClick: onClick
  }, count());
};
const Test = () => {
  const [flag, setFlag] = react.useState(false);
  const [list, setList] = react.useState([]);
  let onClick = () => {
    setFlag(c => !c);
    setList(l => {
      l.push(Math.random().toString());
      return l;
    });
  };
  return /*#__PURE__*/react.createElement("div", {
    style: "background-color: ".concat(flag() ? "blue" : "red", ";")
  }, /*#__PURE__*/react.createElement("button", {
    style: "width: 200px; height: 200px; background-color: green;",
    onClick: onClick
  }, flag()), list().map(d => /*#__PURE__*/react.createElement("div", {
    key: d
  }, /*#__PURE__*/react.createElement(Counter, null))));
};
const App = () => {
  const [flag, setFlag] = react.useState(false);
  let onClick = () => {
    setFlag(c => !c);
  };
  return /*#__PURE__*/react.createElement("div", {
    style: "background-color: ".concat(flag() ? "blue" : "red", ";")
  }, /*#__PURE__*/react.createElement("button", {
    style: "width: 200px; height: 200px; background-color: yellow;",
    onClick: onClick
  }, flag()), /*#__PURE__*/react.createElement(Test, null));
};
/* harmony default export */ const components_App = (App);
;// CONCATENATED MODULE: ./src/index.jsx


react.init( /*#__PURE__*/react.createElement(components_App, {
  name: "foo"
}));
/******/ })()
;