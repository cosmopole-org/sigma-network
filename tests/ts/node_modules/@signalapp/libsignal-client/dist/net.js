"use strict";
//
// Copyright 2023 Signal Messenger, LLC.
// SPDX-License-Identifier: AGPL-3.0-only
//
Object.defineProperty(exports, "__esModule", { value: true });
exports.RestoredSecret = exports.Net = exports.ChatService = exports.TokioAsyncContext = exports.Environment = void 0;
const Native = require("../Native");
const Address_1 = require("./Address");
const DEFAULT_CHAT_REQUEST_TIMEOUT_MILLIS = 5000;
// This must match the libsignal-bridge Rust enum of the same name.
var Environment;
(function (Environment) {
    Environment[Environment["Staging"] = 0] = "Staging";
    Environment[Environment["Production"] = 1] = "Production";
})(Environment = exports.Environment || (exports.Environment = {}));
function newNativeHandle(handle) {
    return {
        _nativeHandle: handle,
    };
}
/** Low-level async runtime control, mostly just exported for testing. */
class TokioAsyncContext {
    constructor(handle) {
        this._nativeHandle = handle;
    }
    makeCancellable(abortSignal, promise) {
        if (abortSignal !== undefined &&
            '_cancellationToken' in promise &&
            typeof promise._cancellationToken === 'bigint') {
            const cancellationToken = promise._cancellationToken;
            const cancel = () => {
                Native.TokioAsyncContext_cancel(this, cancellationToken);
            };
            if (abortSignal.aborted) {
                cancel();
            }
            else {
                abortSignal.addEventListener('abort', cancel);
            }
        }
        return promise;
    }
}
exports.TokioAsyncContext = TokioAsyncContext;
/**
 * Provides API methods to connect and communicate with the Chat Service.
 * Before using either authenticated or unauthenticated channels,
 * a corresponding `connect*` method must be called.
 * It's also important to call {@link #disconnect()} method when the instance is no longer needed.
 */
class ChatService {
    constructor(asyncContext, connectionManager) {
        this.asyncContext = asyncContext;
        this.chatService = newNativeHandle(Native.ChatService_new(connectionManager, '', ''));
    }
    /**
     * Initiates termination of the underlying connection to the Chat Service. After the service is
     * disconnected, it will not attempt to automatically reconnect until you call
     * {@link #connectAuthenticated()} and/or {@link #connectUnauthenticated()}.
     *
     * Note: the same instance of `ChatService` can be reused after `disconnect()` was
     * called.
     */
    disconnect() {
        return Native.ChatService_disconnect(this.asyncContext, this.chatService);
    }
    /**
     * Initiates establishing of the underlying unauthenticated connection to the Chat Service. Once
     * the service is connected, all the requests will be using the established connection. Also, if
     * the connection is lost for any reason other than the call to {@link #disconnect()}, an
     * automatic reconnect attempt will be made.
     *
     * @throws {AppExpiredError} if the current app version is too old (as judged by the server).
     * @throws {LibSignalError} with other codes for other failures.
     */
    connectUnauthenticated(options) {
        return this.asyncContext.makeCancellable(options?.abortSignal, Native.ChatService_connect_unauth(this.asyncContext, this.chatService));
    }
    /**
     * Initiates establishing of the underlying authenticated connection to the Chat Service. Once the
     * service is connected, all the requests will be using the established connection. Also, if the
     * connection is lost for any reason other than the call to {@link #disconnect()}, an automatic
     * reconnect attempt will be made.
     *
     * Calling this method will result in starting to accept incoming requests from the Chat Service.
     *
     * @throws {AppExpiredError} if the current app version is too old (as judged by the server).
     * @throws {DeviceDelinkedError} if the current device has been delinked.
     * @throws {LibSignalError} with other codes for other failures.
     */
    connectAuthenticated(options) {
        return this.asyncContext.makeCancellable(options?.abortSignal, Native.ChatService_connect_auth(this.asyncContext, this.chatService));
    }
    /**
     * Sends request to the Chat Service over an unauthenticated channel.
     *
     * In addition to the response, an object containing debug information about the request flow is
     * returned.
     *
     * @throws {ChatServiceInactive} if you haven't called {@link #connectUnauthenticated()} (as a
     * rejection of the promise).
     */
    unauthenticatedFetchAndDebug(chatRequest, options) {
        return this.asyncContext.makeCancellable(options?.abortSignal, Native.ChatService_unauth_send_and_debug(this.asyncContext, this.chatService, ChatService.buildHttpRequest(chatRequest), chatRequest.timeoutMillis ?? DEFAULT_CHAT_REQUEST_TIMEOUT_MILLIS));
    }
    /**
     * Sends request to the Chat Service over an unauthenticated channel.
     *
     * @throws {ChatServiceInactive} if you haven't called {@link #connectUnauthenticated()} (as a
     * rejection of the promise).
     */
    unauthenticatedFetch(chatRequest, options) {
        return this.asyncContext.makeCancellable(options?.abortSignal, Native.ChatService_unauth_send(this.asyncContext, this.chatService, ChatService.buildHttpRequest(chatRequest), chatRequest.timeoutMillis ?? DEFAULT_CHAT_REQUEST_TIMEOUT_MILLIS));
    }
    /**
     * Sends request to the Chat Service over an authenticated channel.
     *
     * In addition to the response, an object containing debug information about the request flow is
     * returned.
     *
     * @throws {ChatServiceInactive} if you haven't called {@link #connectAuthenticated()} (as a
     * rejection of the promise).
     */
    authenticatedFetchAndDebug(chatRequest, options) {
        return this.asyncContext.makeCancellable(options?.abortSignal, Native.ChatService_auth_send_and_debug(this.asyncContext, this.chatService, ChatService.buildHttpRequest(chatRequest), chatRequest.timeoutMillis ?? DEFAULT_CHAT_REQUEST_TIMEOUT_MILLIS));
    }
    /**
     * Sends request to the Chat Service over an authenticated channel.
     *
     * @throws {ChatServiceInactive} if you haven't called {@link #connectAuthenticated()} (as a
     * rejection of the promise).
     */
    authenticatedFetch(chatRequest, options) {
        return this.asyncContext.makeCancellable(options?.abortSignal, Native.ChatService_auth_send(this.asyncContext, this.chatService, ChatService.buildHttpRequest(chatRequest), chatRequest.timeoutMillis ?? DEFAULT_CHAT_REQUEST_TIMEOUT_MILLIS));
    }
    static buildHttpRequest(chatRequest) {
        const { verb, path, body, headers } = chatRequest;
        const bodyBuffer = body !== undefined ? Buffer.from(body) : null;
        const httpRequest = {
            _nativeHandle: Native.HttpRequest_new(verb, path, bodyBuffer),
        };
        headers.forEach((header) => {
            const [name, value] = header;
            Native.HttpRequest_add_header(httpRequest, name, value);
        });
        return httpRequest;
    }
}
exports.ChatService = ChatService;
class Net {
    constructor(env, userAgent) {
        this.asyncContext = new TokioAsyncContext(Native.TokioAsyncContext_new());
        this.connectionManager = newNativeHandle(Native.ConnectionManager_new(env, userAgent));
        this.svr3 = new Svr3ClientImpl(this.asyncContext, this.connectionManager);
    }
    /**
     * Creates a new instance of {@link ChatService}.
     */
    newChatService() {
        return new ChatService(this.asyncContext, this.connectionManager);
    }
    /**
     * Enables/disables IPv6 for all new connections (until changed).
     *
     * The flag is `true` by default.
     */
    setIpv6Enabled(ipv6Enabled) {
        Native.ConnectionManager_set_ipv6_enabled(this.connectionManager, ipv6Enabled);
    }
    /**
     * Sets the proxy host to be used for all new connections (until overridden).
     *
     * Sets a domain name and port to be used to proxy all new outgoing
     * connections. The proxy can be overridden by calling this method again or
     * unset by calling {@link #clearProxy}.
     *
     * Throws if the host or port is structurally invalid, such as a port that doesn't fit in u16.
     */
    setProxy(host, port) {
        Native.ConnectionManager_set_proxy(this.connectionManager, host, port);
    }
    /**
     * Ensures that future connections will be made directly, not through a proxy.
     *
     * Clears any proxy configuration set via {@link #setProxy}. If none was set, calling this
     * method is a no-op.
     */
    clearProxy() {
        Native.ConnectionManager_clear_proxy(this.connectionManager);
    }
    async cdsiLookup({ username, password }, { e164s, acisAndAccessKeys, returnAcisWithoutUaks, abortSignal, }) {
        const request = newNativeHandle(Native.LookupRequest_new());
        e164s.forEach((e164) => {
            Native.LookupRequest_addE164(request, e164);
        });
        acisAndAccessKeys.forEach(({ aci: aciStr, accessKey: accessKeyStr }) => {
            Native.LookupRequest_addAciAndAccessKey(request, Address_1.Aci.parseFromServiceIdString(aciStr).getServiceIdFixedWidthBinary(), Buffer.from(accessKeyStr, 'base64'));
        });
        Native.LookupRequest_setReturnAcisWithoutUaks(request, returnAcisWithoutUaks);
        const lookup = await this.asyncContext.makeCancellable(abortSignal, Native.CdsiLookup_new(this.asyncContext, this.connectionManager, username, password, request));
        return await this.asyncContext.makeCancellable(abortSignal, Native.CdsiLookup_complete(this.asyncContext, newNativeHandle(lookup)));
    }
}
exports.Net = Net;
/**
 * A simple data class containing the secret restored from SVR3 as well as the
 * number of restore attempts remaining.
 */
class RestoredSecret {
    constructor(serialized) {
        this.triesRemaining = serialized.readInt32BE();
        this.value = serialized.subarray(4);
    }
}
exports.RestoredSecret = RestoredSecret;
class Svr3ClientImpl {
    constructor(asyncContext, connectionManager) {
        this.asyncContext = asyncContext;
        this.connectionManager = connectionManager;
    }
    async backup(what, password, maxTries, auth, options) {
        return this.asyncContext.makeCancellable(options?.abortSignal, Native.Svr3Backup(this.asyncContext, this.connectionManager, what, password, maxTries, auth.username, auth.password));
    }
    async restore(password, shareSet, auth, options) {
        const serialized = await this.asyncContext.makeCancellable(options?.abortSignal, Native.Svr3Restore(this.asyncContext, this.connectionManager, password, shareSet, auth.username, auth.password));
        return new RestoredSecret(serialized);
    }
    async remove(auth, options) {
        return this.asyncContext.makeCancellable(options?.abortSignal, Native.Svr3Remove(this.asyncContext, this.connectionManager, auth.username, auth.password));
    }
}
//# sourceMappingURL=net.js.map